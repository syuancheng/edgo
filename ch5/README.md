# Chapter 5 数据

## 字符串

## 数组
### Define
- 数组长度为非负证书常量表达式
- 长度是类型组成部分
  - 元素类型相同，长度不同不属于同一类型
### 初始化 [ex_5_2_1](./ex_5_2_1.go)
- `var a [2]int`  元素自动初始化为0
- `var b [4]int{2,5}` 未提供初始值的元素初始化为0
- `var c [4]int{2,3: 10}` 指定索引位置初始化
- `b := [...]int{1, 2}` 编译器按照初始化值的数量来决定数组长度
### 多维数组
- 仅第一维允许使用"..."
- 内置函数len和cap都返回第一维度长度
- 如果元素类型支持"==,!="操作符，那么数组也支持
### 指针  [ex_5_2_2](./ex_5_2_2.go)
- 指针数组：元素为指针 `x, y := 10, 20   a := [...]*int{&x, &y}`
- 数组指针：获取数组变量的地址 `p := &a`
### 复制 [ex_5_2_3](./ex_5_2_3.go)
- go数组是值类型
  - 赋值和传参操作都会复制整个数组数据

## 切片
### Define
- 通过指针引用底层数组
- 设定相关属性，将数据读写操作限定在指定区域内
> 切片本身是个只读对象，其工作机制类似数组指针的一种包装
— 可基于数组或数组指针创建切片，以开始和结束索引位置决定所引用的数组片段，实际范围是**左闭右开**
  - cap：表示切片所引用数组片段的真实长度
  - len：用于限定可读写元素数量
  - 数组必须addressable
- 使用索引访问，从0开始，而非底层数组的index
- 创建切片也可无需创建数组， make函数会自动完成底层数组内存分配
- 切片只是很小的结构体对象， 用来代替数组传参可避免复制开销 
  - 并非所有时候都适合切片代替数组，切片底层数组可能会在堆上分配内存，而且小数组在栈上拷贝的消耗也未必就比make大
### 数组创建 [ex_5_3_1.go](./ex_5_3_1.go)
```go
var a []int // a==nil len=0, 不可读,可append, 遍历不需要check nil [ex_5_3_2.go](./ex_5_3_2.go)
b := []int{} //b!=nil len=0
c := make([]int, 2, 10)//len=2 cap=10
d := make([]int, 2)//len=2 cap=2
```

### 比较
- 切片不支持比较操作， 就算元素类型支持也不行
- 智能判断是否为nil
### 指针  [ex_5_3_3.go](./ex_5_3_3.go)
- 可获取元素地址
- 不可以用切片指针访问元素内容

### reslice
- 将切片视作数据源，据此创建新切片对象
  - 不能超出cap，但不受len限制
- 新建切片依旧指向底层数组，也就是修改对所有关联切片可见
- 使用reslice实现栈

### append [ex_5_3_5.go](./ex_5_3_5.go)
```go
func main() {
	//当append向切片中追加元素时， 在空间足够的情况下， 新元素将从x[len(x)]位置开始存放， append会生成一个新的切片
	//但不会修改原切片x
	x := make([]int, 0, 10)
	x = append(x, 1, 2, 3)
	y := append(x, 4)
	z := append(x, 5)
	fmt.Println(x) //1,2,3
	fmt.Println(y) //1,2,3,5
	fmt.Println(z) //1,2,3,5
}
```

## 字典

## 结构
### what is struct?
- 将多个不同类型命名字段序列打包成一个符合类型。
- 要求：
  - 字段名唯一
  - 可用`_`补位
  - 可用自身指针
  - 字段名排列顺序也是类型组成部分
  - 结构体中字段首字母小写时，包外不可见。在当前包中大小写可见性一致
- 初始化
  - 按顺序
  ```go
  type user struct {
    name string
    age byte
  }
  u1 := user{"Tom", 12}
  u2 := user{"Krystal"}//error: too few values in struct initializer
  ```
  - 命名（推荐使用命名初始化， 这样在扩充结构字段或调整字段顺序时，不会导致初始化语句出错）
  ```go
  u := User{
	name: "tom",
	age: 12
  }
  ```
- 匿名结构
```go
u := struct{
	name string
	age int
}{
	name: "tom",
	age: 23
}

type file struct {
    name string
    attr struct {
        owner int
        perm int
    }
}

```
- 比较: 只有struct中所有字段都支持`==`的时候 [ex_5_5_1.go](./ex_5_5_1.go)
- 指针：一级指针可以修改字段，多级不可以 [ex_5_5_2.go](./ex_5_5_2.go)

### 空结构
- `struct{}` 没有字段的结构类型 [ex_5_5_3.go](./ex_5_5_3.go)
  - 没有分配数组内存，但依然可以操作元素，对应切片的len cap属性也正常
  - 空接口可以用作通道元素类型，用于事件通知
### 匿名字段 [ex_5_5_4](./ex_5_5_4.go)
- def:没有名字，只有类型的字段，也叫`嵌入字段`或`嵌入类型`
- 哪些类型可以做
  - 结构体
  - 除了接口指针和多级指针以外的任何命名类型都可以
  - 不能将基础类型和其指针同时嵌入，因为两者隐式名字相同
- 显示和隐式区别
  - 显示指定时与其他类型没有区别，仅仅代表某种类型的字段。而
  - 隐式指定时，原结构体的**字段**和**方法**看起来就像是被**继承**过来一样。
如下，Cat中嵌入了另一个结构体Animal，此时结构体Animal中的字段和方法会被提升到Cat中，看上去就像是Cat的原生字段和方法。
```go
type Animal struct {
	Name string
}

func (a *Animal) SetName(name string) {
	a.Name = name
}

type Cat struct {
	Animal
}

type Dog struct {
	a Animal
}
```

### 字段标签 [ex_5_5_5](./ex_5_5_5.go)
- 字段标签并不是注释，而是用来对字段进行描述的元数据。
- 在运行期，可以用反射获取标签信息。